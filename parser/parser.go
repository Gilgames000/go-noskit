package parser

import (
	"reflect"
	"regexp"

	"github.com/alecthomas/participle"
	"github.com/pkg/errors"
)

// NosPacketParser provides a collection of methods to parse nostale packets
// and convert them between different formats or notations. It also holds an
// initially-empty list of parsable packets.
type NosPacketParser struct {
	registeredNamesRegex *regexp.Regexp
	registeredNames      string
	clientPackets        map[string]reflect.Type
	clientParsers        map[string]*participle.Parser
	serverPackets        map[string]reflect.Type
	serverParsers        map[string]*participle.Parser
}

// New initializes and returns a new packet parser.
func New() *NosPacketParser {
	return &NosPacketParser{
		registeredNamesRegex: regexp.MustCompile(""),
		registeredNames:      "",
		clientPackets:        make(map[string]reflect.Type),
		clientParsers:        make(map[string]*participle.Parser),
		serverPackets:        make(map[string]reflect.Type),
		serverParsers:        make(map[string]*participle.Parser),
	}
}

// PacketType represents the type of a packet
type PacketType int

const (
	// CLIENT specifies that a packet has been generated by the client
	CLIENT PacketType = iota
	// SERVER specifies that a packet has been generated by the server
	SERVER
)

// NosPacket is the interface that a packet must implement
type NosPacket interface {
	Name() string
	Type() PacketType
}

// RegisterPacket adds a new packet to the list of packets that the parser will
// be able to parse.
// In order to be correctly parsed, each exported packet struct field that must
// be parsed shall be labeled with the tag 'index' which represents the index
// of the field in the packet. The struct must also implement the NosPacket
// interface.
// An error is returned if packetType doesn't satisfy the aforementioned
// constraints.
func (p *NosPacketParser) RegisterPacket(packetStruct NosPacket) error {
	var packets map[string]reflect.Type
	packetStructType := reflect.TypeOf(packetStruct)

	// TODO: if already exists?
	// TODO: race conditions?
	// TODO: unregister?

	if packetStructType.Kind() != reflect.Struct {
		return errors.New("invalid packet struct: packetStruct must be a struct")
	}

	packet, ok := packetStruct.(NosPacket)
	if !ok {
		return errors.New("invalid packet struct: packetStruct must implement the NosPacket interface")
	}

	switch packet.Type() {
	case CLIENT:
		packets = p.clientPackets
	case SERVER:
		packets = p.serverPackets
	default:
		return errors.New("invalid packet struct: the 'Type() PacketType' method must return either CLIENT or SERVER")
	}

	// Update the names regex by putting the new name at the beginning
	// if the current regex contains a submatch so that it won't take
	// precedence; put it at the end otherwise
	packets[packet.Name()] = packetStructType
	if p.registeredNamesRegex.Find([]byte(packet.Name())) != nil {
		p.registeredNames = "|" + regexp.QuoteMeta(packet.Name()) + p.registeredNames
	} else {
		p.registeredNames = p.registeredNames + "|" + regexp.QuoteMeta(packet.Name())
	}
	p.registeredNamesRegex = regexp.MustCompile("^(" + p.registeredNames[1:] + ")")

	return nil
}

// ParseClientPacket parses a registered client packet
func (p *NosPacketParser) ParseClientPacket(rawPacket string) (NosPacket, error) {
	return p.parsePacket(rawPacket, CLIENT)
}

// ParseServerPacket parses a registered server packet
func (p *NosPacketParser) ParseServerPacket(rawPacket string) (NosPacket, error) {
	return p.parsePacket(rawPacket, SERVER)
}

func (p *NosPacketParser) parsePacket(rawPacket string, packetType PacketType) (NosPacket, error) {
	var packets map[string]reflect.Type
	var parsers map[string]*participle.Parser

	switch packetType {
	case CLIENT:
		packets = p.clientPackets
		parsers = p.clientParsers
	case SERVER:
		packets = p.serverPackets
		parsers = p.serverParsers
	}

	packetName := string(p.registeredNamesRegex.Find([]byte(rawPacket)))
	packetStructType, ok := packets[packetName]
	if !ok {
		return nil, errors.Errorf("unknown packet: '%s'", rawPacket)
	}

	packetStruct := reflect.New(packetStructType).Interface().(NosPacket)
	packetParser, ok := parsers[packetName]
	if !ok {
		packetParser = participle.MustBuild(
			packetStruct,
			participle.Lexer(NosLexer()),
			participle.Elide("Whitespace"),
		)
	}

	err := packetParser.ParseString(rawPacket, packetStruct)

	return packetStruct, err
}
